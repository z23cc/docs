---
title: '核心操作'
---

# Git 核心操作

掌握了 Git 的基础概念和工作流程后，我们来学习一些最常用、最核心的操作命令。

## 获取 Git 仓库

有两种主要方式开始使用 Git 进行项目管理：

1.  **在现有项目目录中初始化新仓库 (`git init`)**:
    如果你有一个尚未进行版本控制的项目，可以进入项目根目录，然后执行：
    ```bash
    cd /path/to/your/project
    git init
    ```
    这会在当前目录下创建一个名为 `.git` 的隐藏子目录，它包含了仓库的所有必需文件（元数据和对象数据库）。这时你的项目就开始被 Git 管理了，但还没有任何文件被跟踪。

2.  **克隆现有远程仓库 (`git clone`)**:
    如果你想获取一个已经存在的 Git 仓库副本（例如，托管在 GitHub、GitLab 或 Gitee 上的项目），可以使用 `git clone` 命令：
    ```bash
    # 语法: git clone <仓库URL> [可选的本地目录名]
    git clone https://github.com/git/git.git my-git-project
    ```
    这不仅会下载项目的所有文件和完整的历史记录到 `my-git-project` 目录（如果未指定目录名，则默认为仓库名），还会自动设置好与远程仓库的连接（通常命名为 `origin`），方便后续的推送和拉取操作。

**何时使用？**
*   使用 `git init` 开始一个全新的项目，或者将一个现有但未版本控制的项目纳入 Git 管理。
*   使用 `git clone` 获取一个已存在的远程项目的本地副本以进行工作或贡献。

## 检查状态 (`git status`)

`git status` 命令是你最常用的命令之一，它能告诉你当前工作目录和暂存区的状态。

```bash
git status
```

输出会告诉你：
*   当前所在的分支。
*   **Changes to be committed**: 哪些文件已被修改并暂存（在 Staging Area 中），等待下次提交。
*   **Changes not staged for commit**: 哪些已跟踪的文件在工作目录中被修改，但尚未暂存。
*   **Untracked files**: 工作目录中哪些新文件是 Git 尚未开始跟踪的。

![Git 文件生命周期](../images/git-tutorial/git-lifecycle.png)

*Git 文件生命周期：从未跟踪到已跟踪，从工作目录到暂存区再到仓库*

## 跟踪与暂存 (`git add`)

`git add` 命令用于将工作目录中的更改（新文件或已修改文件）添加到暂存区，准备进行下一次提交。

*   **暂存单个文件**:
    ```bash
    git add README.md
    ```
*   **暂存多个文件**:
    ```bash
    git add file1.txt file2.js
    ```
*   **暂存当前目录下所有变化** (包括新文件、修改和删除)：
    ```bash
    git add .
    ```
    *(注意：`.` 代表当前目录及其子目录)*
*   **交互式暂存 (`-p`)**: 对于一个文件中的多处修改，如果你只想暂存其中一部分，可以使用 `-p` 或 `--patch` 选项，Git 会逐块展示差异，让你决定是否暂存该块。
    ```bash
    git add -p <文件名>
    ```

`git add` 是一个多功能命令：可以用它开始跟踪新文件，或者把已修改或已删除的文件暂存起来准备提交。

## 查看更改 (`git diff`)

在暂存或提交之前，查看具体的修改内容非常重要。

*   **查看工作目录相对于暂存区的差异 (`git diff`)**:
    显示已修改但**未暂存**的文件内容变化。
    ```bash
    git diff
    ```
*   **查看暂存区相对于上次提交的差异 (`git diff --staged` 或 `git diff --cached`)**:
    显示已暂存但**未提交**的文件内容变化。这是你在执行 `git commit` 前最后检查修改内容的机会。
    ```bash
    git diff --staged
    ```

![Git 工作流程](../images/git-tutorial/git-workflow.png)

*Git 的三大区域：工作目录、暂存区和 Git 仓库，以及文件在其中的流转*

## 提交更改 (`git commit`)

当你觉得暂存区的内容已经是一个完整的、逻辑一致的改动集合时，就可以使用 `git commit` 将这个快照永久记录到 Git 仓库的历史中。

```bash
# -m 选项直接在命令行提供提交信息
git commit -m "修复登录页面的样式问题"
```

**编写良好的提交信息至关重要！** 它应该简洁地概括本次提交的目的。通常第一行是 50 个字符以内的摘要，空一行后可以写更详细的描述。

*   **跳过暂存区直接提交 (`-a`)**:
    如果你想提交**所有已跟踪文件**的修改（注意：不包括未跟踪的新文件），可以合并 `add` 和 `commit` 步骤：
    ```bash
    # 相当于 git add -u && git commit -m "..."
    git commit -a -m "更新文档和修复拼写错误"
    ```
    *( `-u` 选项告诉 `git add` 只更新已跟踪的文件)*

## 查看提交历史 (`git log`)

`git log` 命令用于按时间倒序列出仓库中的提交记录。

```bash
git log
```

默认输出包含每个提交的 SHA-1 校验和、作者、日期和提交信息。`git log` 有极其丰富的选项来自定义输出：

*   **简化输出**:
    ```bash
    git log --oneline # 每个提交只显示精简的一行 (SHA-1 前缀 + 提交信息)
    git log -n 5      # 只显示最近的 5 次提交
    ```
*   **图形化显示分支历史**:
    ```bash
    git log --graph --oneline --decorate --all # 查看所有分支的图形化历史
    ```
    ![Git 分支历史](../images/git-tutorial/git-branches.png)

*Git 分支历史图示：分支和提交历史的可视化表示*
*   **按条件筛选**:
    ```bash
    git log --author="作者名"
    git log --grep="关键词" # 搜索提交信息包含关键词的提交
    git log --since="2 weeks ago" # 查看最近两周的提交
    git log <文件名>         # 查看特定文件的修改历史
    ```
*   **查看每次提交的详细差异 (`-p`)**:
    ```bash
    git log -p -2 # 显示最近两次提交的详细代码差异
    ```

## 移除文件 (`git rm`)

要从 Git 中彻底移除某个文件（同时从工作目录和版本历史中），需要先从暂存区移除，然后提交。

```bash
# 从工作目录和暂存区删除文件
git rm <文件名>

# 提交这次删除操作
git commit -m "移除不再需要的 <文件名>"
```

如果只想**停止跟踪**某个文件（即从暂存区移除），但希望**保留在工作目录**中（例如，将一个之前误提交的配置文件移出版本控制），使用 `--cached` 选项：

```bash
git rm --cached <配置文件>
git commit -m "停止跟踪 <配置文件>"
# 别忘了将 <配置文件> 添加到 .gitignore 文件中！
```

## 移动或重命名文件 (`git mv`)

要在 Git 中移动或重命名文件，推荐使用 `git mv` 命令。

```bash
git mv <旧文件名或路径> <新文件名或路径>
```

这实际上等同于执行了三条命令：
1.  `mv <旧> <新>` (在文件系统层面移动/重命名)
2.  `git rm <旧>` (暂存旧文件的删除)
3.  `git add <新>` (暂存新文件的添加)

然后你需要提交这次更改：
```bash
git commit -m "重命名/移动 <旧> 到 <新>"
```

虽然 Git 内部并不直接记录“重命名”这个动作，但它足够智能，在比较版本时，如果发现一个文件的内容与之前某个被删除文件的内容高度相似，它会推断出这是一次重命名或移动操作。

## 忽略文件 (`.gitignore`)

通常有些文件我们不希望 Git 进行跟踪和版本控制，例如：
*   编译产生的文件（如 `.class`, `.o`, `.exe`）
*   日志文件 (`.log`)
*   临时的编辑器文件（如 `*~`, `.swp`）
*   依赖包目录（如 `node_modules/`, `vendor/`）
*   包含敏感信息的配置文件

可以在项目根目录下创建一个名为 `.gitignore` 的文本文件，列出要忽略的文件或目录模式。

**示例 `.gitignore` 文件:**

```gitignore
# 忽略所有 .log 文件
*.log

# 忽略 build/ 目录下的所有内容
build/

# 忽略 node_modules 目录
node_modules/

# 忽略特定的配置文件
config.local.yaml

# 但不忽略 lib.a，即使它匹配 *.a
!lib.a
```

Git 会自动忽略 `.gitignore` 文件中列出的匹配项。**强烈建议在项目初期就创建并维护好 `.gitignore` 文件**，并将其添加到版本控制中 (`git add .gitignore` 然后 `git commit`)。

---

这些是 Git 最基本、最常用的核心操作。熟练掌握它们是高效使用 Git 进行版本控制的基础。